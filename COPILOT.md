# COPILOT.md - AI Agent Instructions

This file defines the interaction protocol, coding standards, and workflow for AI agents collaborating on the Vibe Tracing project.

## Project overview

**Vibe Tracing** is a C-based ray tracing engine built in one day through AI-assisted development. The project follows the "Ray Tracing in One Weekend" series and implements a complete path tracer with global illumination, reflections, and refractions.

For full technical details, see `Specification.md`.

## Core principles

- **All code generated by AI agent** (no copy-paste from external sources without attribution)
- **Human review & approval** required before moving to the next phase
- **Token efficiency**: use mini models (0.33x multiplier) for most work; one premium request available
- **Transparent prompting**: all interactions logged in `SESSION.md`
- **Clean separation**: instructions in `COPILOT.md`, session history in `SESSION.md`

## Code style guidelines

Follow standard C best practices (based on Linux kernel style guide):

### Naming conventions
- **Functions & variables**: `snake_case` (e.g., `random_double()`, `hit_record`)
- **Constants & macros**: `UPPER_SNAKE_CASE` (e.g., `MAX_DEPTH`, `PI`)
- **Type definitions**: `snake_case_t` suffix (e.g., `vec3_t`, `ray_t`)

### Formatting
- **Indentation**: 4 spaces (no tabs)
- **Line length**: Maximum 100 characters
- **Braces**: K&R style (opening brace on same line)
  ```c
  if (condition) {
      // code
  }
  ```
- **Comments**: clear and concise; use `//` for line comments, `/* */` for blocks
- **Documentation**: add function documentation in `.h` files describing parameters and return values

### Memory & performance
- **Use `const`** for immutable parameters and pointers to large structs
- **Use `static`** for internal functions (file-local scope)
- **Use `inline`** for small, frequently-called math utilities
- **Avoid global variables** except for constants
- **Cleanup**: always provide cleanup functions for dynamically allocated resources

### Modularity
- **One responsibility per module** (vec3, ray, camera, material, etc.)
- **Clear interfaces**: Headers expose public functions; implementations use static helpers
- **Encapsulation**: Implementation details stay in .c files

## Testing guidelines

Each development step must include:

### 1. Compilation testing
- Code must compile with `make` without warnings
- Use `gcc -Wall -Wextra -pedantic` flags to catch issues early

### 2. Unit tests
- Create `tests/` directory with unit test files for core modules
- Test math operations (vec3 dot product, cross product, normalization)
- Test ray-sphere intersection logic
- Test material scatter functions
- Use a simple assertion-based test framework (e.g., custom `assert_equal()` macro)

### 3. Visual validation
- Generate test PPM images at each step to verify correctness
- Images should be output to `output/` directory
- At minimum: gradient background (step 2), single sphere (step 3), antialiased image (step 4), final scene (step 6)
- Verify output dimensions and format are correct

### 4. Integration testing
- Render a simple scene to verify the full pipeline works end-to-end
- Check that the final image is visually reasonable (bright areas, shadows, reflections)

## Git & commit guidelines

Follow the Conventional Commits specification. After completing each step or fixing a bug, suggest a commit with:

### Commit types
- `feat`: New feature (e.g., `feat: add glass material refraction`)
- `fix`: Bug fix (e.g., `fix: resolve sphere intersection overflow`)
- `docs`: Documentation updates
- `refactor`: Code changes (no bug fix or feature)
- `style`: Formatting, linting
- `test`: Unit test additions or updates
- `chore`: Build, dependency, or config changes

### Commit message format
```
<type>(<scope>): <subject>

<body>

*commit co-authored-by Copilot as part of a a 'vibe-coding' educational project*
```

**example:**
```
feat(materials): implement glass material with Schlick's approximation

Add Dielectric material type with proper refraction using Snell's law
and Schlick's fresnel approximation for reflectance.

*commit co-authored-by Copilot as part of a a 'vibe-coding' educational project*
```

### Commit discipline
- Commit after each working feature (not broken intermediate states)
- One logical change per commit
- Clear, concise messages describing the "what" and "why"
- If a commit fixes an issue, reference it (e.g., "Fixes #5")

## Development workflow

1. **Receive prompt** from human with step-by-step instructions
2. **Implement feature** following all code style and modularity guidelines
3. **Compile & test** (unit tests + visual validation)
4. **Create clean commit(s)** with conventional message
5. **Wait for human review** before proceeding to next step

## Documentation & session logging

All interactions must be logged in `SESSION.md` in the following format:

```
[timestamp] - [feature/task description]

**Prompt:**
[The exact prompt sent to the model]

**Model:** [Model name, e.g., GPT-4o, Claude 3.5 Sonnet, Haiku]
```

**example:**
```
[2026-02-18 11:22:39] - Step 1: Foundation & math module

**Prompt:**
Create a C11 header vec3.h and implementation vec3.c for 3D vector math. Include basic operations (add, sub, mul, div, dot, cross, length) and utilities for random double generation and random unit vectors. Ensure all functions are efficient and follow K&R style.

**Model:** Claude 3.5 Haiku
```

## Resources

- **Specification**: `Specification.md` — complete technical requirements
- **README**: `README.md` — project overview and context
- **Build**: `Makefile` — compile with `make` or `make clean`
- **Output**: `output/` — rendered .ppm images
- **Tests**: `tests/` — unit tests (create as needed)